                      ; ---------------------------------------------------------------
                      ; a09 bitcount.asm -Lbitcount.lst
                      ; python LST2BAS.py bitcount.lst > bitcount.bas
                      ;
                      ; Epson HX-20
                      ;
                      ; This is an example which embeds two functions
                      ; in a single machine language module.
                      ; These functions can be used as USR functions from BASIC.
                      ;
                      ; Martin Hepperle, 2025
                      ; ---------------------------------------------------------------
 
                              ; HX-20: Hitachi 6301
                              OPT H01
 
                              ; no line length limit
                              OPT NCL
 
                      ; BASIC floating point accumulator
                      FPTYP   EQU  $0085    ; 2 bytes: type of number in FPACC
                      FPACC   EQU  $00D5    ; first byte of floating point accumulator
 
 
                              ; load this module below BASIC program
                              ; use MEMSET &H0A88
                              ORG     $0A40
 
                      ;
                      ; Parameter passing for USR functions:
                      ; Register A contains 2 if the parameter is an integer
                      ; For integer variables, register X points to the 16-bit
                      ; integer N% in a 4 byte buffer:
                      ;    X,0 -> n.c.
                      ;    X,1    n.c.
                      ;    X,2    high byte of N%
                      ;    X,3    low byte of N%
                      ; (in fact, X contains the address of FPACC)
                      ; Return the bit count in FPACC or 255 if no integer was given.
                      ;
                      ; The return value is stored in FPACC and its type in FPTYP.
                      ;
                      ; All functions destroy A and B, these are saved when BASIC calls
                      ; the USR functions.
                      ; ---------------------------------------------------------------
 
                      ; Jump table with functions, entries are 2 bytes apart.
                      ; This simplifes the definition of USR functions,
                      ; but slighty slows down each call.
 0A40 201C                    BRA COUNTBITS    ; DEF USR1=&H0A40 : N%=USR1(I%) count bits in i%
 0A42 2000                    BRA LROTBITS     ; DEF USR2=&H0A42 : N%=USR1(I%) rotate i% left by 1
 
                      ; =================================================================
                      ; A USR function for rotating the bits in its integer parameter N% left by 1.
                      ; If the parameter is not an integer, a value of 0 is returned.
                      ; The leftmost bit is rotated into bit 0.
                      ;
                      ; ------
                      ;   I%=USR1(-32757)  10000000'00000001 -> 00000000'00000011
                      ;   ?I%
                      ;   3
                      ; ------
                      ;
                      LROTBITS:
 0A44 8102                    CMPA #$02     ; do we have an integer?
 0A46 2612                    BNE  ERRBITS  ; no: return error value 0
                        
 0A48 A602                    LDAA $2,X     ; get high byte of integer -> A
 0A4A E603                    LDAB $3,X     ; get low byte of integer -> A
 0A4C 58                      ASLB          ; C <- shift A left <- 0
 0A4D 49                      ROLA          ; C <- shift B left <- C
 0A4E 2401                    BCC NOBIT0    ; no carry
                              ; set bit 0
 0A50 5C                      INCB
                      NOBIT0:
                              ; fall through to RETINT
                      ; ---------------------------------------------------------------
                      RETINT:
                      ; common "return integer in (A,B) resp (D)" exit point
                      ; Store 16-bit integer in FPACC+2,3
                      ; FPTYP is set in case the parameter was no integer.
 0A51 97D7                    STAA FPACC+2  ; high byte
 0A53 D7D8                    STAB FPACC+3  ; low byte
 
 0A55 9602                    LDAA $02      ; set return data type: integer
 0A57 9785                    STAA FPTYP    ; type of data in FPACC
 
 0A59 39                      RTS
                      ; ---------------------------------------------------------------
                      ERRBITS:
 0A5A 4F                      CLRA          ; integer 0
 0A5B 5F                      CLRB
 0A5C 20F3                    BRA RETINT    ; return (A,B)
 
                      ; =================================================================
                      ; A USR function for counting the bits in its integer parameter N%.
                      ; If the parameter is not an integer, a value of 255 is returned.
                      ;
                      ; ------
                      ;   I%=USR1(1+2+32)
                      ;   ?I%
                      ;   3
                      ; ------
                      COUNTBITS:
 0A5E 7F0A87                  CLR  BITS     ; prepare...
 0A61 7A0A87                  DEC  BITS     ; ...error return: 255
 
                      ; using a break point:
                      ; BREAK1: FCB     $00   ; TRAP into MONITOR for debugging
                      ; This byte is at address A46.
                      ; Inspect register A
                      ; GA47 continues and returns.
                      ; Use GA47,A47 to execute the next instruction only.
                      ; Use GA47,A48 to execute the next two instructions, etc.
                      ; Use D to inspect memory, e.g. BITCNT.
                      ; B aborts to BASIC without continuing.
 
 0A64 8102                    CMPA #$02     ; do we have an integer?
 0A66 260D                    BNE  ERRCOUNT ; no: return error value 255
                        
 0A68 7F0A87                  CLR  BITS     ; start over
 
 0A6B A603                    LDAA $3,X     ; get low byte of integer -> A
 0A6D BD0A7B                  JSR  BITCNT   ; count bits in A
                              
 0A70 A602                    LDAA $2,X     ; get high byte of integer -> A
 0A72 BD0A7B                  JSR  BITCNT   ; count bits in A
 
                      ERRCOUNT:   
                              ; return BITS [0..16] or 255 if no integer was given  
 0A75 4F                      CLRA          ; zero upperbyte
 0A76 F60A87                  LDAB BITS     ; get bit count
 0A79 20D6                    BRA RETINT    ; return integer in (A,B)
                      ; ---------------------------------------------------------------
                      ; --- subroutine: count bits in A ---
                      BITCNT:
 0A7B C608                    LDAB    #$8      ; loop count
 
 0A7D 47              NEXT:   ASRA             ; shift bit 0 TO CARRY
 0A7E 2403                    BCC     NOPE     ; 0: carry clear
 0A80 7C0A87                  INC     BITS     ; add one
                      NOPE:
 0A83 5A                      DECB             ; decrement bit count
 0A84 26F7                    BNE     NEXT     ; next bit
 0A86 39                      RTS
                      ; ---
                              
 0A87 FF              BITS:   FCB     $FF      ; collects bit count
 
                      MEMSET  *                ; this symbol defines the parameter for MEMSET
 
                              END

SYMBOL TABLE
    BITCNT 02 0A7B      BITS 02 0A87 COUNTBITS 02 0A5E   ERRBITS 02 0A5A
  ERRCOUNT 02 0A75     FPACC 00 00D5     FPTYP 00 0085  LROTBITS 02 0A44
    MEMSET 02 0A88      NEXT 02 0A7D    NOBIT0 02 0A51      NOPE 02 0A83
    RETINT 02 0A51
13 SYMBOLS

0 error(s), 0 warning(s)
